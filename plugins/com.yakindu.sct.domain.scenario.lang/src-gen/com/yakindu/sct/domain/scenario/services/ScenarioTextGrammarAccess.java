/*
 * generated by Xtext
 */
package com.yakindu.sct.domain.scenario.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.yakindu.sct.model.stext.services.STextGrammarAccess;
import org.yakindu.base.expressions.services.ExpressionsGrammarAccess;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class ScenarioTextGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class StateScopeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.yakindu.sct.domain.scenario.ScenarioText.StateScope");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStatScopeAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cScenariosAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cScenariosBlockScenarioParserRuleCall_1_0 = (RuleCall)cScenariosAssignment_1.eContents().get(0);
		private final Assignment cReactionsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cReactionsLocalReactionParserRuleCall_2_0 = (RuleCall)cReactionsAssignment_2.eContents().get(0);
		
		//StateScope sgraph::Scope:
		//	{StatScope} scenarios+=BlockScenario*
		//	reactions+=LocalReaction*
		@Override public ParserRule getRule() { return rule; }

		//{StatScope} scenarios+=BlockScenario* reactions+=LocalReaction*
		public Group getGroup() { return cGroup; }

		//{StatScope}
		public Action getStatScopeAction_0() { return cStatScopeAction_0; }

		//scenarios+=BlockScenario*
		public Assignment getScenariosAssignment_1() { return cScenariosAssignment_1; }

		//BlockScenario
		public RuleCall getScenariosBlockScenarioParserRuleCall_1_0() { return cScenariosBlockScenarioParserRuleCall_1_0; }

		//reactions+=LocalReaction*
		public Assignment getReactionsAssignment_2() { return cReactionsAssignment_2; }

		//LocalReaction
		public RuleCall getReactionsLocalReactionParserRuleCall_2_0() { return cReactionsLocalReactionParserRuleCall_2_0; }
	}

	public class BlockScenarioElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.yakindu.sct.domain.scenario.ScenarioText.BlockScenario");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBlocksKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cEventsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cEventsEventCrossReference_2_0 = (CrossReference)cEventsAssignment_2.eContents().get(0);
		private final RuleCall cEventsEventQIDParserRuleCall_2_0_1 = (RuleCall)cEventsEventCrossReference_2_0.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//BlockScenario:
		//	'blocks' '{'
		//	events+=[types::Event|QID]+ '}';
		@Override public ParserRule getRule() { return rule; }

		//'blocks' '{' events+=[types::Event|QID]+ '}'
		public Group getGroup() { return cGroup; }

		//'blocks'
		public Keyword getBlocksKeyword_0() { return cBlocksKeyword_0; }

		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//events+=[types::Event|QID]+
		public Assignment getEventsAssignment_2() { return cEventsAssignment_2; }

		//[types::Event|QID]
		public CrossReference getEventsEventCrossReference_2_0() { return cEventsEventCrossReference_2_0; }

		//QID
		public RuleCall getEventsEventQIDParserRuleCall_2_0_1() { return cEventsEventQIDParserRuleCall_2_0_1; }

		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	
	
	private final StateScopeElements pStateScope;
	private final BlockScenarioElements pBlockScenario;
	
	private final Grammar grammar;

	private final STextGrammarAccess gaSText;

	private final ExpressionsGrammarAccess gaExpressions;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public ScenarioTextGrammarAccess(GrammarProvider grammarProvider,
		STextGrammarAccess gaSText,
		ExpressionsGrammarAccess gaExpressions,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaSText = gaSText;
		this.gaExpressions = gaExpressions;
		this.gaTerminals = gaTerminals;
		this.pStateScope = new StateScopeElements();
		this.pBlockScenario = new BlockScenarioElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("com.yakindu.sct.domain.scenario.ScenarioText".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	public STextGrammarAccess getSTextGrammarAccess() {
		return gaSText;
	}

	public ExpressionsGrammarAccess getExpressionsGrammarAccess() {
		return gaExpressions;
	}

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//StateScope sgraph::Scope:
	//	{StatScope} scenarios+=BlockScenario*
	//	reactions+=LocalReaction*
	public StateScopeElements getStateScopeAccess() {
		return pStateScope;
	}
	
	public ParserRule getStateScopeRule() {
		return getStateScopeAccess().getRule();
	}

	//BlockScenario:
	//	'blocks' '{'
	//	events+=[types::Event|QID]+ '}';
	public BlockScenarioElements getBlockScenarioAccess() {
		return pBlockScenario;
	}
	
	public ParserRule getBlockScenarioRule() {
		return getBlockScenarioAccess().getRule();
	}

	/// * ---- root rules ----
	//These root rules are not relevant for the grammar integration in the statechart. They just integrate the different start rules consistently 
	//into a single grammar. 
	// * /
	//Root:
	//	roots+=DefRoot*;
	public STextGrammarAccess.RootElements getRootAccess() {
		return gaSText.getRootAccess();
	}
	
	public ParserRule getRootRule() {
		return getRootAccess().getRule();
	}

	//DefRoot:
	//	StatechartRoot | StateRoot | TransitionRoot;
	public STextGrammarAccess.DefRootElements getDefRootAccess() {
		return gaSText.getDefRootAccess();
	}
	
	public ParserRule getDefRootRule() {
		return getDefRootAccess().getRule();
	}

	//StatechartRoot:
	//	'@@statechart@@' def=StatechartSpecification;
	public STextGrammarAccess.StatechartRootElements getStatechartRootAccess() {
		return gaSText.getStatechartRootAccess();
	}
	
	public ParserRule getStatechartRootRule() {
		return getStatechartRootAccess().getRule();
	}

	//StateRoot:
	//	'@@state@@' def=StateSpecification;
	public STextGrammarAccess.StateRootElements getStateRootAccess() {
		return gaSText.getStateRootAccess();
	}
	
	public ParserRule getStateRootRule() {
		return getStateRootAccess().getRule();
	}

	//TransitionRoot:
	//	'@@transition@@' def=TransitionSpecification;
	public STextGrammarAccess.TransitionRootElements getTransitionRootAccess() {
		return gaSText.getTransitionRootAccess();
	}
	
	public ParserRule getTransitionRootRule() {
		return getTransitionRootAccess().getRule();
	}

	/// * ---- start rules ----
	//Define the starting points used by the statechart integration. These rules hook in the concrete rules of the specific grammar.
	// * /
	//ScopedElement sgraph::ScopedElement:
	//	StatechartSpecification
	public STextGrammarAccess.ScopedElementElements getScopedElementAccess() {
		return gaSText.getScopedElementAccess();
	}
	
	public ParserRule getScopedElementRule() {
		return getScopedElementAccess().getRule();
	}

	//StatechartSpecification:
	//	{StatechartSpecification} ('namespace' namespace=FQN)?
	//	scopes+=StatechartScope*;
	public STextGrammarAccess.StatechartSpecificationElements getStatechartSpecificationAccess() {
		return gaSText.getStatechartSpecificationAccess();
	}
	
	public ParserRule getStatechartSpecificationRule() {
		return getStatechartSpecificationAccess().getRule();
	}

	//StateSpecification:
	//	scope=super::StateScope;
	public STextGrammarAccess.StateSpecificationElements getStateSpecificationAccess() {
		return gaSText.getStateSpecificationAccess();
	}
	
	public ParserRule getStateSpecificationRule() {
		return getStateSpecificationAccess().getRule();
	}

	//TransitionSpecification:
	//	reaction=TransitionReaction;
	public STextGrammarAccess.TransitionSpecificationElements getTransitionSpecificationAccess() {
		return gaSText.getTransitionSpecificationAccess();
	}
	
	public ParserRule getTransitionSpecificationRule() {
		return getTransitionSpecificationAccess().getRule();
	}

	//Scope sgraph::Scope:
	//	super::StateScope | StatechartScope
	public STextGrammarAccess.ScopeElements getScopeAccess() {
		return gaSText.getScopeAccess();
	}
	
	public ParserRule getScopeRule() {
		return getScopeAccess().getRule();
	}

	//StatechartScope:
	//	InterfaceScope | InternalScope | ImportScope;
	public STextGrammarAccess.StatechartScopeElements getStatechartScopeAccess() {
		return gaSText.getStatechartScopeAccess();
	}
	
	public ParserRule getStatechartScopeRule() {
		return getStatechartScopeAccess().getRule();
	}

	//NamedInterfaceScope base::NamedElement:
	//	InterfaceScope
	public STextGrammarAccess.NamedInterfaceScopeElements getNamedInterfaceScopeAccess() {
		return gaSText.getNamedInterfaceScopeAccess();
	}
	
	public ParserRule getNamedInterfaceScopeRule() {
		return getNamedInterfaceScopeAccess().getRule();
	}

	//InterfaceScope:
	//	{InterfaceScope} 'interface' name=XID? ':' declarations+=(EventDefinition | VariableDefinition | TypeAliasDefinition
	//	| OperationDefinition)*;
	public STextGrammarAccess.InterfaceScopeElements getInterfaceScopeAccess() {
		return gaSText.getInterfaceScopeAccess();
	}
	
	public ParserRule getInterfaceScopeRule() {
		return getInterfaceScopeAccess().getRule();
	}

	//InternalScope:
	//	{InternalScope} 'internal' ':' (declarations+=(EventDefinition | VariableDefinition | OperationDefinition |
	//	TypeAliasDefinition) | reactions+=LocalReaction)*;
	public STextGrammarAccess.InternalScopeElements getInternalScopeAccess() {
		return gaSText.getInternalScopeAccess();
	}
	
	public ParserRule getInternalScopeRule() {
		return getInternalScopeAccess().getRule();
	}

	//ImportScope:
	//	{ImportScope} 'import' ':' imports+=[types::Package|QID]*;
	public STextGrammarAccess.ImportScopeElements getImportScopeAccess() {
		return gaSText.getImportScopeAccess();
	}
	
	public ParserRule getImportScopeRule() {
		return getImportScopeAccess().getRule();
	}

	//QID:
	//	ID ('.' ID)*;
	public STextGrammarAccess.QIDElements getQIDAccess() {
		return gaSText.getQIDAccess();
	}
	
	public ParserRule getQIDRule() {
		return getQIDAccess().getRule();
	}

	//Declaration types::Declaration:
	//	EventDefinition | VariableDefinition | OperationDefinition | TypeAliasDefinition
	public STextGrammarAccess.DeclarationElements getDeclarationAccess() {
		return gaSText.getDeclarationAccess();
	}
	
	public ParserRule getDeclarationRule() {
		return getDeclarationAccess().getRule();
	}

	//EventDefinition:
	//	direction=Direction? 'event' name=XID (':' typeSpecifier=TypeSpecifier)?;
	public STextGrammarAccess.EventDefinitionElements getEventDefinitionAccess() {
		return gaSText.getEventDefinitionAccess();
	}
	
	public ParserRule getEventDefinitionRule() {
		return getEventDefinitionAccess().getRule();
	}

	//enum Direction returns types::Direction:
	//	LOCAL='local' | IN='in' | OUT='out';
	public STextGrammarAccess.DirectionElements getDirectionAccess() {
		return gaSText.getDirectionAccess();
	}
	
	public EnumRule getDirectionRule() {
		return getDirectionAccess().getRule();
	}

	//VariableDefinition:
	//	{VariableDefinition} (const?='const' | 'var') (readonly?='readonly'? & external?='external'?) name=XID ':'
	//	typeSpecifier=TypeSpecifier ('=' initialValue=Expression)?;
	public STextGrammarAccess.VariableDefinitionElements getVariableDefinitionAccess() {
		return gaSText.getVariableDefinitionAccess();
	}
	
	public ParserRule getVariableDefinitionRule() {
		return getVariableDefinitionAccess().getRule();
	}

	/// * ---- operation definition ---- * / TypeAliasDefinition:
	//	{TypeAliasDefinition} 'alias' name=XID ':' typeSpecifier=TypeSpecifier;
	public STextGrammarAccess.TypeAliasDefinitionElements getTypeAliasDefinitionAccess() {
		return gaSText.getTypeAliasDefinitionAccess();
	}
	
	public ParserRule getTypeAliasDefinitionRule() {
		return getTypeAliasDefinitionAccess().getRule();
	}

	//OperationDefinition:
	//	{OperationDefinition} 'operation' name=XID '(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')' (':'
	//	typeSpecifier=TypeSpecifier)?;
	public STextGrammarAccess.OperationDefinitionElements getOperationDefinitionAccess() {
		return gaSText.getOperationDefinitionAccess();
	}
	
	public ParserRule getOperationDefinitionRule() {
		return getOperationDefinitionAccess().getRule();
	}

	//TypeSpecifier types::TypeSpecifier:
	//	type=[types::Type|FQN] ('<' (typeArguments+=TypeSpecifier (',' typeArguments+=TypeSpecifier)* '>'))?
	public STextGrammarAccess.TypeSpecifierElements getTypeSpecifierAccess() {
		return gaSText.getTypeSpecifierAccess();
	}
	
	public ParserRule getTypeSpecifierRule() {
		return getTypeSpecifierAccess().getRule();
	}

	//Parameter types::Parameter:
	//	name=XID varArgs?='...'? ':' typeSpecifier=TypeSpecifier
	public STextGrammarAccess.ParameterElements getParameterAccess() {
		return gaSText.getParameterAccess();
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}

	//Reaction sgraph::Reaction:
	//	LocalReaction | TransitionReaction
	public STextGrammarAccess.ReactionElements getReactionAccess() {
		return gaSText.getReactionAccess();
	}
	
	public ParserRule getReactionRule() {
		return getReactionAccess().getRule();
	}

	//LocalReaction:
	//	trigger=ReactionTrigger => ('/' effect=ReactionEffect);
	public STextGrammarAccess.LocalReactionElements getLocalReactionAccess() {
		return gaSText.getLocalReactionAccess();
	}
	
	public ParserRule getLocalReactionRule() {
		return getLocalReactionAccess().getRule();
	}

	//TransitionReaction:
	//	{TransitionReaction} trigger=StextTrigger? ('/' effect=ReactionEffect)? ('#' properties+=TransitionProperty*)?;
	public STextGrammarAccess.TransitionReactionElements getTransitionReactionAccess() {
		return gaSText.getTransitionReactionAccess();
	}
	
	public ParserRule getTransitionReactionRule() {
		return getTransitionReactionAccess().getRule();
	}

	//StextTrigger sgraph::Trigger:
	//	ReactionTrigger | DefaultTrigger
	public STextGrammarAccess.StextTriggerElements getStextTriggerAccess() {
		return gaSText.getStextTriggerAccess();
	}
	
	public ParserRule getStextTriggerRule() {
		return getStextTriggerAccess().getRule();
	}

	//ReactionTrigger sgraph::Trigger:
	//	{ReactionTrigger} (triggers+=EventSpec ("," triggers+=EventSpec)* (=> '[' guard=Guard ']')? | '[' guard=Guard
	//	']')
	public STextGrammarAccess.ReactionTriggerElements getReactionTriggerAccess() {
		return gaSText.getReactionTriggerAccess();
	}
	
	public ParserRule getReactionTriggerRule() {
		return getReactionTriggerAccess().getRule();
	}

	//DefaultTrigger sgraph::Trigger:
	//	{DefaultTrigger} ('default' | 'else')
	public STextGrammarAccess.DefaultTriggerElements getDefaultTriggerAccess() {
		return gaSText.getDefaultTriggerAccess();
	}
	
	public ParserRule getDefaultTriggerRule() {
		return getDefaultTriggerAccess().getRule();
	}

	//Guard:
	//	{Guard} expression=Expression;
	public STextGrammarAccess.GuardElements getGuardAccess() {
		return gaSText.getGuardAccess();
	}
	
	public ParserRule getGuardRule() {
		return getGuardAccess().getRule();
	}

	//ReactionEffect sgraph::Effect:
	//	{ReactionEffect} actions+=(Expression | EventRaisingExpression) (=> ';' actions+=(Expression |
	//	EventRaisingExpression))*
	public STextGrammarAccess.ReactionEffectElements getReactionEffectAccess() {
		return gaSText.getReactionEffectAccess();
	}
	
	public ParserRule getReactionEffectRule() {
		return getReactionEffectAccess().getRule();
	}

	//TransitionProperty sgraph::ReactionProperty:
	//	EntryPointSpec | ExitPointSpec
	public STextGrammarAccess.TransitionPropertyElements getTransitionPropertyAccess() {
		return gaSText.getTransitionPropertyAccess();
	}
	
	public ParserRule getTransitionPropertyRule() {
		return getTransitionPropertyAccess().getRule();
	}

	//EntryPointSpec:
	//	'>' entrypoint=ID;
	public STextGrammarAccess.EntryPointSpecElements getEntryPointSpecAccess() {
		return gaSText.getEntryPointSpecAccess();
	}
	
	public ParserRule getEntryPointSpecRule() {
		return getEntryPointSpecAccess().getRule();
	}

	//ExitPointSpec:
	//	exitpoint=ID '>';
	public STextGrammarAccess.ExitPointSpecElements getExitPointSpecAccess() {
		return gaSText.getExitPointSpecAccess();
	}
	
	public ParserRule getExitPointSpecRule() {
		return getExitPointSpecAccess().getRule();
	}

	//EventSpec:
	//	RegularEventSpec | TimeEventSpec | BuiltinEventSpec;
	public STextGrammarAccess.EventSpecElements getEventSpecAccess() {
		return gaSText.getEventSpecAccess();
	}
	
	public ParserRule getEventSpecRule() {
		return getEventSpecAccess().getRule();
	}

	//// Use SimpleFeatureCall for eventSpec to avoid guard ambiguity with array access
	//RegularEventSpec:
	//	event=SimpleFeatureCall;
	public STextGrammarAccess.RegularEventSpecElements getRegularEventSpecAccess() {
		return gaSText.getRegularEventSpecAccess();
	}
	
	public ParserRule getRegularEventSpecRule() {
		return getRegularEventSpecAccess().getRule();
	}

	//SimpleFeatureCall exp::Expression:
	//	SimpleElementReferenceExpression ({exp::FeatureCall.owner=current} '.' feature=[ecore::EObject] (=>
	//	operationCall?='(' (args+=Expression (',' args+=Expression)*)?
	//	')')?)*
	public STextGrammarAccess.SimpleFeatureCallElements getSimpleFeatureCallAccess() {
		return gaSText.getSimpleFeatureCallAccess();
	}
	
	public ParserRule getSimpleFeatureCallRule() {
		return getSimpleFeatureCallAccess().getRule();
	}

	//SimpleElementReferenceExpression exp::ElementReferenceExpression:
	//	reference=[ecore::EObject] (=> operationCall?='(' (args+=Expression (',' args+=Expression)*)?
	//	')')?
	public STextGrammarAccess.SimpleElementReferenceExpressionElements getSimpleElementReferenceExpressionAccess() {
		return gaSText.getSimpleElementReferenceExpressionAccess();
	}
	
	public ParserRule getSimpleElementReferenceExpressionRule() {
		return getSimpleElementReferenceExpressionAccess().getRule();
	}

	//TimeEventSpec:
	//	type=TimeEventType value=ConditionalExpression unit=TimeUnit;
	public STextGrammarAccess.TimeEventSpecElements getTimeEventSpecAccess() {
		return gaSText.getTimeEventSpecAccess();
	}
	
	public ParserRule getTimeEventSpecRule() {
		return getTimeEventSpecAccess().getRule();
	}

	//enum TimeEventType:
	//	after | every;
	public STextGrammarAccess.TimeEventTypeElements getTimeEventTypeAccess() {
		return gaSText.getTimeEventTypeAccess();
	}
	
	public EnumRule getTimeEventTypeRule() {
		return getTimeEventTypeAccess().getRule();
	}

	//BuiltinEventSpec:
	//	EntryEvent | ExitEvent | AlwaysEvent;
	public STextGrammarAccess.BuiltinEventSpecElements getBuiltinEventSpecAccess() {
		return gaSText.getBuiltinEventSpecAccess();
	}
	
	public ParserRule getBuiltinEventSpecRule() {
		return getBuiltinEventSpecAccess().getRule();
	}

	//EntryEvent:
	//	{EntryEvent} 'entry';
	public STextGrammarAccess.EntryEventElements getEntryEventAccess() {
		return gaSText.getEntryEventAccess();
	}
	
	public ParserRule getEntryEventRule() {
		return getEntryEventAccess().getRule();
	}

	//ExitEvent:
	//	{ExitEvent} 'exit';
	public STextGrammarAccess.ExitEventElements getExitEventAccess() {
		return gaSText.getExitEventAccess();
	}
	
	public ParserRule getExitEventRule() {
		return getExitEventAccess().getRule();
	}

	//AlwaysEvent:
	//	{AlwaysEvent} ('always' | 'oncycle');
	public STextGrammarAccess.AlwaysEventElements getAlwaysEventAccess() {
		return gaSText.getAlwaysEventAccess();
	}
	
	public ParserRule getAlwaysEventRule() {
		return getAlwaysEventAccess().getRule();
	}

	//EventRaisingExpression exp::Expression:
	//	{EventRaisingExpression} 'raise' event=FeatureCall (':' value=Expression)?
	public STextGrammarAccess.EventRaisingExpressionElements getEventRaisingExpressionAccess() {
		return gaSText.getEventRaisingExpressionAccess();
	}
	
	public ParserRule getEventRaisingExpressionRule() {
		return getEventRaisingExpressionAccess().getRule();
	}

	//EventValueReferenceExpression exp::Expression:
	//	{EventValueReferenceExpression} 'valueof' '(' value=FeatureCall ')'
	public STextGrammarAccess.EventValueReferenceExpressionElements getEventValueReferenceExpressionAccess() {
		return gaSText.getEventValueReferenceExpressionAccess();
	}
	
	public ParserRule getEventValueReferenceExpressionRule() {
		return getEventValueReferenceExpressionAccess().getRule();
	}

	//ActiveStateReferenceExpression exp::Expression:
	//	{ActiveStateReferenceExpression} 'active' '(' value=[sgraph::State|FQN] ')'
	public STextGrammarAccess.ActiveStateReferenceExpressionElements getActiveStateReferenceExpressionAccess() {
		return gaSText.getActiveStateReferenceExpressionAccess();
	}
	
	public ParserRule getActiveStateReferenceExpressionRule() {
		return getActiveStateReferenceExpressionAccess().getRule();
	}

	//PrimaryExpression exp::Expression:
	//	PrimitiveValueExpression | FeatureCall | ActiveStateReferenceExpression | EventValueReferenceExpression |
	//	ParenthesizedExpression
	public STextGrammarAccess.PrimaryExpressionElements getPrimaryExpressionAccess() {
		return gaSText.getPrimaryExpressionAccess();
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}

	//enum TimeUnit:
	//	second='s' | millisecond='ms' | microsecond='us' | nanosecond='ns';
	public STextGrammarAccess.TimeUnitElements getTimeUnitAccess() {
		return gaSText.getTimeUnitAccess();
	}
	
	public EnumRule getTimeUnitRule() {
		return getTimeUnitAccess().getRule();
	}

	//XID:
	//	ID | 'namespace' | 'interface' | 'internal' | 'event' | 'local' | 'in' | 'out' | 'var' | 'readonly' | 'external' |
	//	'operation' | 'default' | 'else' | 'entry' | 'exit' | 'always' | 'oncycle' | 'raise' | 'valueof' | 'active';
	public STextGrammarAccess.XIDElements getXIDAccess() {
		return gaSText.getXIDAccess();
	}
	
	public ParserRule getXIDRule() {
		return getXIDAccess().getRule();
	}

	//FQN:
	//	XID ('.' XID)*;
	public STextGrammarAccess.FQNElements getFQNAccess() {
		return gaSText.getFQNAccess();
	}
	
	public ParserRule getFQNRule() {
		return getFQNAccess().getRule();
	}

	//Expression:
	//	AssignmentExpression;
	public ExpressionsGrammarAccess.ExpressionElements getExpressionAccess() {
		return gaExpressions.getExpressionAccess();
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//AssignmentExpression Expression:
	//	ConditionalExpression ({AssignmentExpression.varRef=current} operator=AssignmentOperator
	//	expression=ConditionalExpression)*
	public ExpressionsGrammarAccess.AssignmentExpressionElements getAssignmentExpressionAccess() {
		return gaExpressions.getAssignmentExpressionAccess();
	}
	
	public ParserRule getAssignmentExpressionRule() {
		return getAssignmentExpressionAccess().getRule();
	}

	//ConditionalExpression Expression:
	//	LogicalOrExpression ({ConditionalExpression.condition=current} '?' trueCase=LogicalOrExpression ':'
	//	falseCase=LogicalOrExpression)?
	public ExpressionsGrammarAccess.ConditionalExpressionElements getConditionalExpressionAccess() {
		return gaExpressions.getConditionalExpressionAccess();
	}
	
	public ParserRule getConditionalExpressionRule() {
		return getConditionalExpressionAccess().getRule();
	}

	//LogicalOrExpression Expression:
	//	LogicalAndExpression ({LogicalOrExpression.leftOperand=current} LogicalOrOperator
	//	rightOperand=LogicalAndExpression)*
	public ExpressionsGrammarAccess.LogicalOrExpressionElements getLogicalOrExpressionAccess() {
		return gaExpressions.getLogicalOrExpressionAccess();
	}
	
	public ParserRule getLogicalOrExpressionRule() {
		return getLogicalOrExpressionAccess().getRule();
	}

	//LogicalAndExpression Expression:
	//	LogicalNotExpression ({LogicalAndExpression.leftOperand=current} LogicalAndOperator
	//	rightOperand=LogicalNotExpression)*
	public ExpressionsGrammarAccess.LogicalAndExpressionElements getLogicalAndExpressionAccess() {
		return gaExpressions.getLogicalAndExpressionAccess();
	}
	
	public ParserRule getLogicalAndExpressionRule() {
		return getLogicalAndExpressionAccess().getRule();
	}

	//LogicalNotExpression Expression:
	//	BitwiseXorExpression | {LogicalNotExpression} LogicalNotOperator
	//	operand=BitwiseXorExpression
	public ExpressionsGrammarAccess.LogicalNotExpressionElements getLogicalNotExpressionAccess() {
		return gaExpressions.getLogicalNotExpressionAccess();
	}
	
	public ParserRule getLogicalNotExpressionRule() {
		return getLogicalNotExpressionAccess().getRule();
	}

	//BitwiseXorExpression Expression:
	//	BitwiseOrExpression ({BitwiseXorExpression.leftOperand=current} BitwiseXOrOperator
	//	rightOperand=BitwiseOrExpression)*
	public ExpressionsGrammarAccess.BitwiseXorExpressionElements getBitwiseXorExpressionAccess() {
		return gaExpressions.getBitwiseXorExpressionAccess();
	}
	
	public ParserRule getBitwiseXorExpressionRule() {
		return getBitwiseXorExpressionAccess().getRule();
	}

	//BitwiseOrExpression Expression:
	//	BitwiseAndExpression ({BitwiseOrExpression.leftOperand=current} BitwiseOrOperator
	//	rightOperand=BitwiseAndExpression)*
	public ExpressionsGrammarAccess.BitwiseOrExpressionElements getBitwiseOrExpressionAccess() {
		return gaExpressions.getBitwiseOrExpressionAccess();
	}
	
	public ParserRule getBitwiseOrExpressionRule() {
		return getBitwiseOrExpressionAccess().getRule();
	}

	//BitwiseAndExpression Expression:
	//	LogicalRelationExpression ({BitwiseAndExpression.leftOperand=current} BitwiseAndOperator
	//	rightOperand=LogicalRelationExpression)*
	public ExpressionsGrammarAccess.BitwiseAndExpressionElements getBitwiseAndExpressionAccess() {
		return gaExpressions.getBitwiseAndExpressionAccess();
	}
	
	public ParserRule getBitwiseAndExpressionRule() {
		return getBitwiseAndExpressionAccess().getRule();
	}

	//LogicalRelationExpression Expression:
	//	ShiftExpression ({LogicalRelationExpression.leftOperand=current} operator=RelationalOperator
	//	rightOperand=ShiftExpression)*
	public ExpressionsGrammarAccess.LogicalRelationExpressionElements getLogicalRelationExpressionAccess() {
		return gaExpressions.getLogicalRelationExpressionAccess();
	}
	
	public ParserRule getLogicalRelationExpressionRule() {
		return getLogicalRelationExpressionAccess().getRule();
	}

	//ShiftExpression Expression:
	//	NumericalAddSubtractExpression ({ShiftExpression.leftOperand=current} operator=ShiftOperator
	//	rightOperand=NumericalAddSubtractExpression)*
	public ExpressionsGrammarAccess.ShiftExpressionElements getShiftExpressionAccess() {
		return gaExpressions.getShiftExpressionAccess();
	}
	
	public ParserRule getShiftExpressionRule() {
		return getShiftExpressionAccess().getRule();
	}

	//NumericalAddSubtractExpression Expression:
	//	NumericalMultiplyDivideExpression ({NumericalAddSubtractExpression.leftOperand=current} operator=AdditiveOperator
	//	rightOperand=NumericalMultiplyDivideExpression)*
	public ExpressionsGrammarAccess.NumericalAddSubtractExpressionElements getNumericalAddSubtractExpressionAccess() {
		return gaExpressions.getNumericalAddSubtractExpressionAccess();
	}
	
	public ParserRule getNumericalAddSubtractExpressionRule() {
		return getNumericalAddSubtractExpressionAccess().getRule();
	}

	//NumericalMultiplyDivideExpression Expression:
	//	NumericalUnaryExpression ({NumericalMultiplyDivideExpression.leftOperand=current} operator=MultiplicativeOperator
	//	rightOperand=NumericalUnaryExpression)*
	public ExpressionsGrammarAccess.NumericalMultiplyDivideExpressionElements getNumericalMultiplyDivideExpressionAccess() {
		return gaExpressions.getNumericalMultiplyDivideExpressionAccess();
	}
	
	public ParserRule getNumericalMultiplyDivideExpressionRule() {
		return getNumericalMultiplyDivideExpressionAccess().getRule();
	}

	//NumericalUnaryExpression Expression:
	//	TypeCastExpression | {NumericalUnaryExpression} operator=UnaryOperator operand=TypeCastExpression
	public ExpressionsGrammarAccess.NumericalUnaryExpressionElements getNumericalUnaryExpressionAccess() {
		return gaExpressions.getNumericalUnaryExpressionAccess();
	}
	
	public ParserRule getNumericalUnaryExpressionRule() {
		return getNumericalUnaryExpressionAccess().getRule();
	}

	//TypeCastExpression Expression:
	//	super::PrimaryExpression (({TypeCastExpression.operand=current} 'as') type=[types::Type|super::QID])*
	public ExpressionsGrammarAccess.TypeCastExpressionElements getTypeCastExpressionAccess() {
		return gaExpressions.getTypeCastExpressionAccess();
	}
	
	public ParserRule getTypeCastExpressionRule() {
		return getTypeCastExpressionAccess().getRule();
	}

	//PrimitiveValueExpression Expression:
	//	{PrimitiveValueExpression} value=Literal
	public ExpressionsGrammarAccess.PrimitiveValueExpressionElements getPrimitiveValueExpressionAccess() {
		return gaExpressions.getPrimitiveValueExpressionAccess();
	}
	
	public ParserRule getPrimitiveValueExpressionRule() {
		return getPrimitiveValueExpressionAccess().getRule();
	}

	//FeatureCall Expression:
	//	ElementReferenceExpression ({FeatureCall.owner=current} '.' feature=[ecore::EObject] (=> operationCall?='('
	//	(args+=Expression (',' args+=Expression)*)? ')'
	//	|
	//	=> (arrayAccess?='[' arraySelector+=Expression ']') => ('[' arraySelector+=Expression ']')*)?)*
	public ExpressionsGrammarAccess.FeatureCallElements getFeatureCallAccess() {
		return gaExpressions.getFeatureCallAccess();
	}
	
	public ParserRule getFeatureCallRule() {
		return getFeatureCallAccess().getRule();
	}

	//ElementReferenceExpression Expression:
	//	{ElementReferenceExpression} reference=[ecore::EObject] (=> operationCall?='(' (args+=Expression (','
	//	args+=Expression)*)? ')'
	//	|
	//	=> (arrayAccess?='[' arraySelector+=Expression ']') => ('[' arraySelector+=Expression ']')*)?
	public ExpressionsGrammarAccess.ElementReferenceExpressionElements getElementReferenceExpressionAccess() {
		return gaExpressions.getElementReferenceExpressionAccess();
	}
	
	public ParserRule getElementReferenceExpressionRule() {
		return getElementReferenceExpressionAccess().getRule();
	}

	//ParenthesizedExpression Expression:
	//	{ParenthesizedExpression} '(' expression=Expression ')'
	public ExpressionsGrammarAccess.ParenthesizedExpressionElements getParenthesizedExpressionAccess() {
		return gaExpressions.getParenthesizedExpressionAccess();
	}
	
	public ParserRule getParenthesizedExpressionRule() {
		return getParenthesizedExpressionAccess().getRule();
	}

	//Literal:
	//	BoolLiteral | IntLiteral | HexLiteral | DoubleLiteral | FloatLiteral | StringLiteral | NullLiteral;
	public ExpressionsGrammarAccess.LiteralElements getLiteralAccess() {
		return gaExpressions.getLiteralAccess();
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}

	//BoolLiteral:
	//	{BoolLiteral} value=BOOL;
	public ExpressionsGrammarAccess.BoolLiteralElements getBoolLiteralAccess() {
		return gaExpressions.getBoolLiteralAccess();
	}
	
	public ParserRule getBoolLiteralRule() {
		return getBoolLiteralAccess().getRule();
	}

	//IntLiteral:
	//	{IntLiteral} value=INT;
	public ExpressionsGrammarAccess.IntLiteralElements getIntLiteralAccess() {
		return gaExpressions.getIntLiteralAccess();
	}
	
	public ParserRule getIntLiteralRule() {
		return getIntLiteralAccess().getRule();
	}

	//DoubleLiteral:
	//	{DoubleLiteral} value=DOUBLE;
	public ExpressionsGrammarAccess.DoubleLiteralElements getDoubleLiteralAccess() {
		return gaExpressions.getDoubleLiteralAccess();
	}
	
	public ParserRule getDoubleLiteralRule() {
		return getDoubleLiteralAccess().getRule();
	}

	//FloatLiteral:
	//	{FloatLiteral} value=FLOAT;
	public ExpressionsGrammarAccess.FloatLiteralElements getFloatLiteralAccess() {
		return gaExpressions.getFloatLiteralAccess();
	}
	
	public ParserRule getFloatLiteralRule() {
		return getFloatLiteralAccess().getRule();
	}

	//HexLiteral:
	//	{HexLiteral} value=HEX;
	public ExpressionsGrammarAccess.HexLiteralElements getHexLiteralAccess() {
		return gaExpressions.getHexLiteralAccess();
	}
	
	public ParserRule getHexLiteralRule() {
		return getHexLiteralAccess().getRule();
	}

	//StringLiteral:
	//	{StringLiteral} value=STRING;
	public ExpressionsGrammarAccess.StringLiteralElements getStringLiteralAccess() {
		return gaExpressions.getStringLiteralAccess();
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}

	//NullLiteral:
	//	{NullLiteral} 'null';
	public ExpressionsGrammarAccess.NullLiteralElements getNullLiteralAccess() {
		return gaExpressions.getNullLiteralAccess();
	}
	
	public ParserRule getNullLiteralRule() {
		return getNullLiteralAccess().getRule();
	}

	//LogicalAndOperator:
	//	'&&';
	public ExpressionsGrammarAccess.LogicalAndOperatorElements getLogicalAndOperatorAccess() {
		return gaExpressions.getLogicalAndOperatorAccess();
	}
	
	public ParserRule getLogicalAndOperatorRule() {
		return getLogicalAndOperatorAccess().getRule();
	}

	//LogicalOrOperator:
	//	'||';
	public ExpressionsGrammarAccess.LogicalOrOperatorElements getLogicalOrOperatorAccess() {
		return gaExpressions.getLogicalOrOperatorAccess();
	}
	
	public ParserRule getLogicalOrOperatorRule() {
		return getLogicalOrOperatorAccess().getRule();
	}

	//LogicalNotOperator:
	//	'!';
	public ExpressionsGrammarAccess.LogicalNotOperatorElements getLogicalNotOperatorAccess() {
		return gaExpressions.getLogicalNotOperatorAccess();
	}
	
	public ParserRule getLogicalNotOperatorRule() {
		return getLogicalNotOperatorAccess().getRule();
	}

	//BitwiseXOrOperator:
	//	'^';
	public ExpressionsGrammarAccess.BitwiseXOrOperatorElements getBitwiseXOrOperatorAccess() {
		return gaExpressions.getBitwiseXOrOperatorAccess();
	}
	
	public ParserRule getBitwiseXOrOperatorRule() {
		return getBitwiseXOrOperatorAccess().getRule();
	}

	//BitwiseOrOperator:
	//	'|';
	public ExpressionsGrammarAccess.BitwiseOrOperatorElements getBitwiseOrOperatorAccess() {
		return gaExpressions.getBitwiseOrOperatorAccess();
	}
	
	public ParserRule getBitwiseOrOperatorRule() {
		return getBitwiseOrOperatorAccess().getRule();
	}

	//BitwiseAndOperator:
	//	'&';
	public ExpressionsGrammarAccess.BitwiseAndOperatorElements getBitwiseAndOperatorAccess() {
		return gaExpressions.getBitwiseAndOperatorAccess();
	}
	
	public ParserRule getBitwiseAndOperatorRule() {
		return getBitwiseAndOperatorAccess().getRule();
	}

	//enum AssignmentOperator:
	//	assign='='
	//	| multAssign='*='
	//	| divAssign='/='
	//	| modAssign='%='
	//	| addAssign='+='
	//	| subAssign='-='
	//	| leftShiftAssign='<<='
	//	| rightShiftAssign='>>='
	//	| andAssign='&='
	//	| xorAssign='^='
	//	| orAssign='|=';
	public ExpressionsGrammarAccess.AssignmentOperatorElements getAssignmentOperatorAccess() {
		return gaExpressions.getAssignmentOperatorAccess();
	}
	
	public EnumRule getAssignmentOperatorRule() {
		return getAssignmentOperatorAccess().getRule();
	}

	//enum ShiftOperator:
	//	left='<<'
	//	| right='>>';
	public ExpressionsGrammarAccess.ShiftOperatorElements getShiftOperatorAccess() {
		return gaExpressions.getShiftOperatorAccess();
	}
	
	public EnumRule getShiftOperatorRule() {
		return getShiftOperatorAccess().getRule();
	}

	//enum AdditiveOperator:
	//	plus='+' | minus='-';
	public ExpressionsGrammarAccess.AdditiveOperatorElements getAdditiveOperatorAccess() {
		return gaExpressions.getAdditiveOperatorAccess();
	}
	
	public EnumRule getAdditiveOperatorRule() {
		return getAdditiveOperatorAccess().getRule();
	}

	//enum MultiplicativeOperator:
	//	mul='*' | div='/' | mod='%';
	public ExpressionsGrammarAccess.MultiplicativeOperatorElements getMultiplicativeOperatorAccess() {
		return gaExpressions.getMultiplicativeOperatorAccess();
	}
	
	public EnumRule getMultiplicativeOperatorRule() {
		return getMultiplicativeOperatorAccess().getRule();
	}

	//enum UnaryOperator:
	//	positive='+' | negative='-' | complement='~';
	public ExpressionsGrammarAccess.UnaryOperatorElements getUnaryOperatorAccess() {
		return gaExpressions.getUnaryOperatorAccess();
	}
	
	public EnumRule getUnaryOperatorRule() {
		return getUnaryOperatorAccess().getRule();
	}

	//enum RelationalOperator:
	//	smaller='<' | smallerEqual='<=' | greater='>' | greaterEqual='>=' |
	//	equals='==' | notEquals='!=';
	public ExpressionsGrammarAccess.RelationalOperatorElements getRelationalOperatorAccess() {
		return gaExpressions.getRelationalOperatorAccess();
	}
	
	public EnumRule getRelationalOperatorRule() {
		return getRelationalOperatorAccess().getRule();
	}

	//terminal BOOL returns ecore::EBoolean:
	//	'true' | 'false' | 'yes' | 'no';
	public TerminalRule getBOOLRule() {
		return gaExpressions.getBOOLRule();
	} 

	//terminal HEX returns ecore::EInt:
	//	'0' ('x' | 'X') ('0'..'9' | 'a'..'f' | 'A'..'F')+;
	public TerminalRule getHEXRule() {
		return gaExpressions.getHEXRule();
	} 

	//terminal DOUBLE returns ecore::EDouble:
	//	(INT '.' INT) ('e' ('-' | '+') INT)? ('d' | 'D')?;
	public TerminalRule getDOUBLERule() {
		return gaExpressions.getDOUBLERule();
	} 

	//terminal FLOAT returns ecore::EFloat:
	//	(INT '.' INT) ('e' ('-' | '+') INT)? ('f' | 'F')?;
	public TerminalRule getFLOATRule() {
		return gaExpressions.getFLOATRule();
	} 

	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' | "'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
